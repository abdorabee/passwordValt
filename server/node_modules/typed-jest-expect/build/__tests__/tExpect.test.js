"use strict";

var _ = require("..");

test(`tExpect`, async () => {
  (0, _.tExpect)(0).not.toEqual(1);
  await (0, _.tExpect)(Promise.resolve(0)).resolves.toEqual(0);
  await (0, _.tExpect)(Promise.reject(`error`)).rejects.toEqual(`error`);
  (0, _.tExpect)(0).toBe(0);
  const sum = jest.fn((a, b) => a + b);
  (0, _.tExpect)(sum).not.toHaveBeenCalled();
  (0, _.tExpect)(sum).not.toBeCalled();
  sum(3, 5);
  (0, _.tExpect)(sum).toHaveBeenCalled();
  (0, _.tExpect)(sum).toBeCalled();
  (0, _.tExpect)(sum).toHaveBeenCalledWith(3, 5);
  (0, _.tExpect)(sum).toBeCalledWith(3, 5);
  (0, _.tExpect)(sum).toHaveBeenLastCalledWith(3, 5);
  (0, _.tExpect)(sum).lastCalledWith(3, 5);
  sum(7, 11);
  (0, _.tExpect)(sum).toHaveBeenLastCalledWith(7, 11);
  (0, _.tExpect)(sum).lastCalledWith(7, 11);
  (0, _.tExpect)(sum).toHaveBeenNthCalledWith(1, 3, 5);
  (0, _.tExpect)(sum).nthCalledWith(1, 3, 5);
  (0, _.tExpect)(sum).toHaveReturned();
  (0, _.tExpect)(sum).toReturn();
  (0, _.tExpect)(sum).toHaveReturnedTimes(2);
  (0, _.tExpect)(sum).toReturnTimes(2);
  (0, _.tExpect)(sum).toHaveReturnedWith(8);
  (0, _.tExpect)(sum).toReturnWith(8);
  (0, _.tExpect)(sum).toHaveLastReturnedWith(18);
  (0, _.tExpect)(sum).lastReturnedWith(18);
  (0, _.tExpect)(sum).toHaveNthReturnedWith(1, 8);
  (0, _.tExpect)(sum).toHaveNthReturnedWith(2, 18);
  (0, _.tExpect)(sum).nthReturnedWith(1, 8);
  (0, _.tExpect)(sum).nthReturnedWith(2, 18);
  (0, _.tExpect)([]).toHaveLength(0);
  (0, _.tExpect)([1, 2]).toHaveLength(2);
  (0, _.tExpect)({
    length: 4
  }).toHaveLength(4);
  (0, _.tExpect)({
    foo: `bar`
  }).toHaveProperty(`foo`, `bar`);
  (0, _.tExpect)(0.2 + 0.1).toBeCloseTo(0.3, 5);
  const maybeUndefined = true ? 1 : undefined;
  (0, _.tExpect)(maybeUndefined).toBeDefined();
  (0, _.tExpect)(0).toBeFalsy();
  (0, _.tExpect)(1).toBeGreaterThan(0);
  (0, _.tExpect)(1).toBeGreaterThanOrEqual(1);
  (0, _.tExpect)(0).toBeLessThan(1);
  (0, _.tExpect)(0).toBeLessThanOrEqual(0);

  class Animal {
    constructor(kind) {
      this.kind = kind;
    }

  }

  class Dog extends Animal {
    constructor() {
      super(`dog`);
    }

  }

  const cat = new Animal(`cat`);
  (0, _.tExpect)(cat).toBeInstanceOf(Animal);
  (0, _.tExpect)(cat).not.toBeInstanceOf(Dog);
  const dog = new Dog();
  (0, _.tExpect)(dog).toBeInstanceOf(Animal);
  (0, _.tExpect)(dog).toBeInstanceOf(Dog);
  const maybeNull = true ? null : 1;
  (0, _.tExpect)(maybeNull).toBeNull();
  (0, _.tExpect)([]).toBeTruthy();
  (0, _.tExpect)(maybeUndefined).not.toBeUndefined();
  (0, _.tExpect)(0 / 0).toBeNaN();
  (0, _.tExpect)([1, 2, 3]).toContain(2);
  const t = [{
    foo: `bar`
  }, {
    fizz: `buzz`
  }];
  (0, _.tExpect)(t).not.toContain({
    fizz: `buzz`
  });
  (0, _.tExpect)(t).toContain(t[1]);
  (0, _.tExpect)(t).toContainEqual({
    fizz: `buzz`
  });
  (0, _.tExpect)(t[0]).toEqual({
    foo: `bar`
  });
  (0, _.tExpect)(`fizz`).toMatch(/^f.z*$/);
  (0, _.tExpect)({
    foo: `bar`,
    fizz: `buzz`
  }).toMatchObject({
    foo: `bar`
  });
  (0, _.tExpect)(dog).toStrictEqual(dog);
  (0, _.tExpect)(dog).not.toStrictEqual({
    kind: `dog`
  });

  const throwError = () => {
    throw new Error(`error`);
  };

  (0, _.tExpect)(throwError).toThrow(`error`);
  (0, _.tExpect)(throwError).toThrowError(`error`);
});
//# sourceMappingURL=tExpect.test.js.map