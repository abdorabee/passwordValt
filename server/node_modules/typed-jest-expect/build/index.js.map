{"version":3,"file":"index.js","names":["tExpect","t","expect"],"sources":["../src/index.ts"],"sourcesContent":["// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype TMockFn<R = any, Args extends any[] = any> = jest.Mock<R, Args>;\n\ntype TNumber = number | BigInt;\n\ntype TConstructor<T> = {\n  new (...args: never): T;\n};\n\ntype TFunction<R = unknown, Args extends unknown[] = never[]> = (\n  ...args: Args\n) => R;\n\ntype TPromisify<T> = T extends (...args: never[]) => unknown\n  ? (...args: Parameters<T>) => Promise<ReturnType<T>>\n  : never;\n\ntype TPromisifyAll<T> = {\n  readonly [K in keyof T]: TPromisify<T[K]>;\n};\n\ntype TExpectAsync<T> = Omit<TPromisifyAll<TExpect<T>>, `not`> & {\n  readonly not: TPromisifyAll<TExpect<T>>;\n};\n\nexport type TExpect<T> = {\n  readonly not: TExpect<T>;\n  readonly resolves: T extends Promise<infer U> ? TExpectAsync<U> : never;\n  readonly rejects: T extends Promise<unknown> ? TExpectAsync<unknown> : never;\n  readonly toBe: (result: T) => void;\n  readonly toHaveBeenCalled: T extends TMockFn ? () => void : never;\n  readonly toBeCalled: T extends TMockFn ? () => void : never;\n  readonly toHaveBeenCalledTimes: T extends TMockFn\n    ? (n: number) => void\n    : never;\n  readonly toBeCalledTimes: T extends TMockFn ? (n: number) => void : never;\n  readonly toHaveBeenCalledWith: T extends TMockFn\n    ? (...args: Parameters<T>) => void\n    : never;\n  readonly toBeCalledWith: T extends TMockFn\n    ? (...args: Parameters<T>) => void\n    : never;\n  readonly toHaveBeenLastCalledWith: T extends TMockFn\n    ? (...args: Parameters<T>) => void\n    : never;\n  readonly lastCalledWith: T extends TMockFn\n    ? (...args: Parameters<T>) => void\n    : never;\n  readonly toHaveBeenNthCalledWith: T extends TMockFn\n    ? (n: number, ...args: Parameters<T>) => void\n    : never;\n  readonly nthCalledWith: T extends TMockFn\n    ? (n: number, ...args: Parameters<T>) => void\n    : never;\n  readonly toHaveReturned: T extends TMockFn ? () => void : never;\n  readonly toReturn: T extends TMockFn ? () => void : never;\n  readonly toHaveReturnedTimes: T extends TMockFn ? (n: number) => void : never;\n  readonly toReturnTimes: T extends TMockFn ? (n: number) => void : never;\n  readonly toHaveReturnedWith: T extends TMockFn\n    ? (value: ReturnType<T>) => void\n    : never;\n  readonly toReturnWith: T extends TMockFn\n    ? (value: ReturnType<T>) => void\n    : never;\n  readonly toHaveLastReturnedWith: T extends TMockFn\n    ? (value: ReturnType<T>) => void\n    : never;\n  readonly lastReturnedWith: T extends TMockFn\n    ? (value: ReturnType<T>) => void\n    : never;\n  readonly toHaveNthReturnedWith: T extends TMockFn\n    ? (n: number, value: ReturnType<T>) => void\n    : never;\n  readonly nthReturnedWith: T extends TMockFn\n    ? (n: number, value: ReturnType<T>) => void\n    : never;\n  readonly toHaveLength: T extends {\n    readonly length: number;\n  }\n    ? (length: number) => void\n    : never;\n  // We only support direct property key, no array of keys or dot-separated paths\n  readonly toHaveProperty: <K extends keyof T>(key: K, value?: T[K]) => void;\n  readonly toBeCloseTo: T extends TNumber\n    ? (n: TNumber, digits?: number) => void\n    : never;\n  readonly toBeDefined: undefined extends T ? () => void : never;\n  readonly toBeFalsy: () => void;\n  readonly toBeGreaterThan: T extends TNumber ? (n: TNumber) => void : never;\n  readonly toBeGreaterThanOrEqual: T extends TNumber\n    ? (n: TNumber) => void\n    : never;\n  readonly toBeLessThan: T extends TNumber ? (n: TNumber) => void : never;\n  readonly toBeLessThanOrEqual: T extends TNumber\n    ? (n: TNumber) => void\n    : never;\n  readonly toBeInstanceOf: T extends object\n    ? (Class: TConstructor<T>) => void\n    : never;\n  readonly toBeNull: null extends T ? () => void : never;\n  readonly toBeTruthy: () => void;\n  readonly toBeUndefined: undefined extends T ? () => void : never;\n  readonly toBeNaN: T extends number ? () => void : never;\n  readonly toContain: T extends Readonly<Array<infer U>>\n    ? (item: U) => void\n    : never;\n  readonly toContainEqual: T extends Readonly<Array<infer U>>\n    ? (item: U) => void\n    : never;\n  readonly toEqual: (result: T) => void;\n  readonly toMatch: T extends string ? (match: RegExp | string) => void : never;\n  // We only support matching a single object, not an array.\n  readonly toMatchObject: (result: Partial<T>) => void;\n  readonly toMatchSnapshot: (\n    propertyMatchers?: Partial<T>,\n    hint?: string,\n  ) => void;\n  readonly toMatchInlineSnapshot: (\n    propertyMatchers: Partial<T>,\n    inlineSnapshot: string,\n  ) => void;\n  readonly toStrictEqual: (result: T) => void;\n  readonly toThrow: T extends TFunction<unknown, []>\n    ? (error?: unknown) => void\n    : never;\n  readonly toThrowError: T extends TFunction<unknown, []>\n    ? (error?: unknown) => void\n    : never;\n  readonly toThrowErrorMatchingSnapshot: T extends TMockFn\n    ? (hint?: string) => void\n    : never;\n  readonly toThrowErrorMatchingInlineSnapshot: T extends TMockFn\n    ? (inlineSnapshot: string) => void\n    : never;\n};\n\nexport const tExpect = <T>(t: T): TExpect<T> =>\n  expect(t) as unknown as TExpect<T>;\n"],"mappings":";;;;;;;AAAA;AAwIO,MAAMA,OAAO,GAAOC,CAAJ,IACrBC,MAAM,CAACD,CAAD,CADD"}