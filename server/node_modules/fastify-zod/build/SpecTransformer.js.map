{"version":3,"file":"SpecTransformer.js","names":["isRef","ref","isRecord","$ref","toRefPath","indexOfPath","indexOf","basePath","slice","path","split","toRef","refPath","join","isSpecSchema","input","properties","additionalProperties","patternProperties","items","isSpecSchemas","value","Object","values","isOpenApiSpec","components","paths","schemas","isSwaggerSpec","definitions","isSpec","deepClone","spec","JSON","parse","stringify","defaultExtractSchemaPropertiesKey","withTimings","fn","begin","performance","now","result","end","delta","SpecTransformer","constructor","DEBUG","Error","schemasPath","initialSchemaKeys","getSchemaKeys","_DEBUG","args","console","debug","throw","error","inspect","depth","getSchemaPath","schemaKey","getChildPath","getSchema","schema","getAtPath","keys","createSchemaKey","parentSchemaKey","schemaKeysOptions","parts","removeInitialSchemasPrefix","includes","push","baseName","changeCase","pascalCase","camelCase","paramCase","snakeCase","getAtPathSafe","resolveRef","length","nextRef","setAtPath","deleteAtPath","findFirstDeep","predicate","hasProperRef","schemaPath","equalPath","matchPathPrefix","deleteUnusedSchemas","dirty","rewriteSchemaAbsoluteRefs","visitDeep","nextPath","rewriteSchemasAbsoluteRefs","extractSchemaPathAsSchema","prevSchemaKey","prevRelativePath","nextSchemaKey","prevPath","prevValue","hasValueAtNextPath","valueAtNextPath","deepEqual","replacePathPrefix","extractSchemaPropertiesAtKey","propertiesKey","globalDirty","k","property","extractSchemaProperties","propertiesKeys","extractSchemasProperties","mergeRef","prev$ref","next$ref","mergeRefs","$refs","transformWithTimings","opts","total","map","extractSchemasPropertiesKeys","Array","isArray","schemaKeys","timings","transform"],"sources":["../src/SpecTransformer.ts"],"sourcesContent":["import { inspect } from \"util\";\n\nimport { camelCase, pascalCase, snakeCase, paramCase } from \"change-case\";\nimport deepEqual from \"fast-deep-equal\";\n\nimport {\n  deleteAtPath,\n  equalPath,\n  getAtPath,\n  getAtPathSafe,\n  getChildPath,\n  matchPathPrefix,\n  replacePathPrefix,\n  setAtPath,\n} from \"./Path\";\nimport { findFirstDeep, isRecord, visitDeep } from \"./util\";\n\ntype Ref = {\n  $ref: string;\n};\n\nconst isRef = (ref: unknown): ref is Ref => {\n  if (!isRecord(ref)) {\n    return false;\n  }\n  return typeof ref.$ref === `string`;\n};\n\ntype RefPath = {\n  readonly basePath: string;\n  readonly path: string[];\n};\n\nconst toRefPath = ($ref: string): RefPath => {\n  const indexOfPath = $ref.indexOf(`#`);\n  return {\n    basePath: $ref.slice(0, indexOfPath),\n    path: $ref\n      .slice(indexOfPath + 1)\n      .split(`/`)\n      .slice(1),\n  };\n};\n\nconst toRef = (refPath: RefPath): Ref => ({\n  $ref: [`${refPath.basePath}#`, ...refPath.path].join(`/`),\n});\n\ntype SpecSchema = {\n  readonly properties?: Record<string, unknown>;\n  readonly additionalProperties?: boolean | Record<string, unknown>;\n  readonly patternProperties?: Record<string, unknown>;\n  readonly items?: Record<string, unknown>;\n};\n\nconst isSpecSchema = (input: unknown): input is SpecSchema => {\n  if (!isRecord(input)) {\n    return false;\n  }\n  const { properties, additionalProperties, patternProperties, items } = input;\n  if (typeof properties !== `undefined` && !isRecord(properties)) {\n    return false;\n  }\n\n  if (\n    typeof additionalProperties !== `undefined` &&\n    typeof additionalProperties !== `boolean` &&\n    !isRecord(additionalProperties)\n  ) {\n    return false;\n  }\n\n  if (\n    typeof patternProperties !== `undefined` &&\n    typeof patternProperties !== `boolean` &&\n    !isRecord(patternProperties)\n  ) {\n    return false;\n  }\n\n  if (typeof items !== `undefined` && !isRecord(items)) {\n    return false;\n  }\n\n  return true;\n};\n\ntype SpecSchemas = Record<string, SpecSchema>;\n\nconst isSpecSchemas = (input: unknown): input is SpecSchemas => {\n  if (!isRecord(input)) {\n    return false;\n  }\n  for (const value of Object.values(input)) {\n    if (!isSpecSchema(value)) {\n      return false;\n    }\n  }\n  return true;\n};\n\ntype OpenApiSpec = {\n  readonly components: {\n    readonly schemas: SpecSchemas;\n  };\n  readonly paths?: Record<string, unknown>;\n};\n\nconst isOpenApiSpec = (input: unknown): input is OpenApiSpec => {\n  if (!isRecord(input)) {\n    return false;\n  }\n  const { components, paths } = input;\n  if (!isRecord(components)) {\n    return false;\n  }\n  const { schemas } = components;\n  if (!isSpecSchemas(schemas)) {\n    return false;\n  }\n  if (typeof paths !== `undefined` && !isRecord(paths)) {\n    return false;\n  }\n  return true;\n};\n\ntype SwaggerSpec = {\n  readonly definitions: SpecSchemas;\n  readonly paths?: Record<string, unknown>;\n};\n\nconst isSwaggerSpec = (input: unknown): input is SwaggerSpec => {\n  if (!isRecord(input)) {\n    return false;\n  }\n  const { definitions, paths } = input;\n  if (!isSpecSchemas(definitions)) {\n    return false;\n  }\n  if (typeof paths !== `undefined` && !isRecord(paths)) {\n    return false;\n  }\n  return true;\n};\n\nexport type Spec = OpenApiSpec | SwaggerSpec;\n\nconst isSpec = (input: unknown): input is Spec =>\n  isOpenApiSpec(input) || isSwaggerSpec(input);\n\nconst deepClone = (spec: Spec): Spec => JSON.parse(JSON.stringify(spec));\n\ntype ExtractSchemaPropertiesKey =\n  | `properties`\n  | `additionalProperties`\n  | `patternProperties`\n  | `items`;\n\nconst defaultExtractSchemaPropertiesKey: ExtractSchemaPropertiesKey[] = [\n  `properties`,\n  `additionalProperties`,\n  `patternProperties`,\n  `items`,\n];\n\ntype Timings = {\n  readonly begin: number;\n  readonly end: number;\n  readonly delta: number;\n};\n\nconst withTimings = <T>(fn: () => T): [result: T, timings: Timings] => {\n  const begin = performance.now();\n  const result = fn();\n  const end = performance.now();\n\n  return [\n    result,\n    {\n      begin,\n      end,\n      delta: end - begin,\n    },\n  ];\n};\n\ntype TransformWithTimingsResult = {\n  readonly spec: Spec;\n  readonly timings: {\n    readonly rewriteSchemasAbsoluteRefs: Timings;\n    readonly extractSchemasProperties: Timings;\n    readonly mergeRefs: Timings;\n    readonly deleteUnusedSchemas: Timings;\n    readonly total: Timings;\n  };\n};\n\ntype SchemaKeysOptions = {\n  readonly removeInitialSchemasPrefix?: boolean;\n  readonly changeCase?:\n    | `preserve`\n    | `camelCase`\n    | `PascalCase`\n    | `snake_case`\n    | `param-case`;\n};\n\nexport type TransformOptions = {\n  readonly rewriteSchemasAbsoluteRefs?: boolean;\n  readonly extractSchemasProperties?: boolean | ExtractSchemaPropertiesKey[];\n  readonly mergeRefs?: Ref[];\n  readonly deleteUnusedSchemas?: boolean;\n  readonly schemaKeys?: SchemaKeysOptions;\n};\n\nexport class SpecTransformer {\n  private readonly DEBUG: boolean;\n  private readonly spec: Spec;\n  private readonly initialSchemaKeys: string[];\n\n  private readonly schemasPath: string[];\n\n  public constructor(spec: unknown, DEBUG = false) {\n    if (!isSpec(spec)) {\n      throw new Error(`spec is not an OpenApiSpec or a SwaggerSpec`);\n    }\n    this.spec = deepClone(spec);\n    this.schemasPath = isOpenApiSpec(spec)\n      ? [`components`, `schemas`]\n      : [`definitions`];\n    this.initialSchemaKeys = this.getSchemaKeys();\n    this.DEBUG = DEBUG;\n  }\n\n  private readonly _DEBUG = (...args: unknown[]): void => {\n    if (this.DEBUG) {\n      console.debug(...args);\n    }\n  };\n\n  private readonly throw = (error: unknown): never => {\n    if (this.DEBUG) {\n      console.debug(inspect(this.spec, { depth: null }));\n      console.error(error);\n    }\n    throw error;\n  };\n\n  private readonly getSchemaPath = (schemaKey: string): string[] =>\n    getChildPath(getChildPath(this.schemasPath, schemaKey));\n\n  private readonly getSchema = (schemaKey: string): SpecSchema => {\n    const schema = this.getAtPath(this.getSchemaPath(schemaKey));\n    if (!isSpecSchema(schema)) {\n      return this.throw(new Error(`schema is not a SpecSchema`));\n    }\n    return schema;\n  };\n\n  private readonly getSchemaKeys = (): string[] => {\n    const schemas = this.getAtPath(this.schemasPath);\n    if (!isRecord(schemas)) {\n      return this.throw(new Error(`schemas is not a Record`));\n    }\n    return Object.keys(schemas);\n  };\n\n  private readonly createSchemaKey = (\n    parentSchemaKey: string,\n    path: string[],\n    schemaKeysOptions?: SchemaKeysOptions,\n  ): string => {\n    const parts: string[] = [];\n    if (\n      !schemaKeysOptions?.removeInitialSchemasPrefix ||\n      !this.initialSchemaKeys.includes(parentSchemaKey)\n    ) {\n      parts.push(parentSchemaKey);\n    }\n    parts.push(...path);\n    const baseName = parts.join(`_`);\n    const schemaKey =\n      schemaKeysOptions?.changeCase === `PascalCase`\n        ? pascalCase(baseName)\n        : schemaKeysOptions?.changeCase === `camelCase`\n        ? camelCase(baseName)\n        : schemaKeysOptions?.changeCase === `param-case`\n        ? paramCase(baseName)\n        : schemaKeysOptions?.changeCase === `snake_case`\n        ? snakeCase(baseName)\n        : baseName;\n    if (this.getSchemaKeys().includes(schemaKey)) {\n      throw new Error(`schemaKey(schemaKey='${schemaKey}') already exists`);\n    }\n    return schemaKey;\n  };\n\n  private readonly getAtPath = (path: string[]): unknown =>\n    getAtPath(this.spec, path);\n\n  private readonly getAtPathSafe = (\n    path: string[],\n  ): [valueFound: boolean, value: unknown] => getAtPathSafe(this.spec, path);\n\n  private readonly resolveRef = (\n    $ref: string,\n  ): [value: unknown, $ref: string] => {\n    const refPath = toRefPath($ref);\n    if (refPath.basePath.length > 0) {\n      const nextRef = toRef({\n        basePath: ``,\n        path: getChildPath(\n          this.getSchemaPath(refPath.basePath),\n          ...refPath.path,\n        ),\n      });\n      return this.resolveRef(nextRef.$ref);\n    }\n    const value = this.getAtPath(refPath.path);\n    if (isRef(value)) {\n      return this.resolveRef(value.$ref);\n    }\n    return [value, $ref];\n  };\n\n  private readonly setAtPath = (path: string[], value: unknown): void => {\n    this._DEBUG(`setAtPath`, { path, value });\n    return setAtPath(this.spec, path, value);\n  };\n\n  private readonly deleteAtPath = (path: string[]): void => {\n    this._DEBUG(`deleteAtPath`, { path });\n    return deleteAtPath(this.spec, path);\n  };\n\n  private readonly findFirstDeep = (\n    predicate: (value: unknown, path: string[]) => boolean,\n  ): [found: boolean, value: unknown, path: string[]] =>\n    findFirstDeep(this.spec, predicate);\n\n  private readonly hasProperRef = (schemaKey: string): boolean => {\n    const schemaPath = this.getSchemaPath(schemaKey);\n    const [hasProperRef] = this.findFirstDeep((value, path) => {\n      if (equalPath(path, schemaPath)) {\n        return false;\n      }\n      if (isRef(value)) {\n        const refPath = toRefPath(value.$ref);\n        return (\n          refPath.basePath.length === 0 &&\n          matchPathPrefix(schemaPath, refPath.path)\n        );\n      }\n      return false;\n    });\n    return hasProperRef;\n  };\n\n  private readonly deleteUnusedSchemas = (): void => {\n    this._DEBUG(`deleteUnusedSchemas`);\n    let dirty = true;\n    while (dirty) {\n      dirty = false;\n      for (const schemaKey of this.getSchemaKeys()) {\n        if (!this.hasProperRef(schemaKey)) {\n          this.deleteAtPath(this.getSchemaPath(schemaKey));\n          dirty = true;\n          break;\n        }\n      }\n    }\n  };\n\n  private readonly rewriteSchemaAbsoluteRefs = (schemaKey: string): boolean => {\n    const schema = this.getSchema(schemaKey);\n    const schemaPath = this.getSchemaPath(schemaKey);\n    let dirty = false;\n    visitDeep(schema, (value) => {\n      if (isRef(value)) {\n        const refPath = toRefPath(value.$ref);\n        if (\n          refPath.basePath.length === 0 &&\n          !matchPathPrefix(schemaPath, refPath.path)\n        ) {\n          const nextPath = getChildPath(schemaPath, ...refPath.path);\n          value.$ref = toRef({ basePath: ``, path: nextPath }).$ref;\n          dirty = true;\n        }\n      }\n    });\n    return dirty;\n  };\n\n  private readonly rewriteSchemasAbsoluteRefs = (): void => {\n    this._DEBUG(`rewriteSchemasAbsoluteRefs`);\n    let dirty = true;\n    while (dirty) {\n      dirty = false;\n      for (const schemaKey of this.getSchemaKeys()) {\n        if (this.rewriteSchemaAbsoluteRefs(schemaKey)) {\n          dirty = true;\n          break;\n        }\n      }\n    }\n  };\n\n  private readonly extractSchemaPathAsSchema = (\n    prevSchemaKey: string,\n    prevRelativePath: string[],\n    nextSchemaKey: string,\n  ): boolean => {\n    const prevPath = getChildPath(\n      this.getSchemaPath(prevSchemaKey),\n      ...prevRelativePath,\n    );\n\n    const prevValue = this.getAtPath(prevPath);\n    const nextPath = this.getSchemaPath(nextSchemaKey);\n\n    const [hasValueAtNextPath, valueAtNextPath] = this.getAtPathSafe(nextPath);\n\n    if (hasValueAtNextPath) {\n      if (!deepEqual(prevValue, valueAtNextPath)) {\n        this.throw(\n          new Error(\n            `schema(schemaKey='${nextSchemaKey}') already exists with a different value`,\n          ),\n        );\n      }\n    } else {\n      this.setAtPath(nextPath, prevValue);\n    }\n\n    this.setAtPath(prevPath, toRef({ basePath: ``, path: nextPath }));\n\n    let dirty = false;\n    visitDeep(this.spec, (value) => {\n      if (isRef(value)) {\n        const refPath = toRefPath(value.$ref);\n        if (\n          refPath.basePath.length === 0 &&\n          matchPathPrefix(prevPath, refPath.path)\n        ) {\n          value.$ref = toRef({\n            basePath: ``,\n            path: replacePathPrefix(prevPath, nextPath, refPath.path),\n          }).$ref;\n          dirty = true;\n        }\n      }\n    });\n    return dirty;\n  };\n\n  private readonly extractSchemaPropertiesAtKey = (\n    parentSchemaKey: string,\n    propertiesKey: ExtractSchemaPropertiesKey,\n    schemaKeysOptions?: SchemaKeysOptions,\n  ): boolean => {\n    let globalDirty = false;\n    let dirty = true;\n    while (dirty) {\n      dirty = false;\n      if (\n        propertiesKey === `properties` ||\n        propertiesKey === `additionalProperties` ||\n        propertiesKey === `patternProperties`\n      ) {\n        const properties = this.getSchema(parentSchemaKey)[propertiesKey];\n        if (isRecord(properties)) {\n          for (const k of Object.keys(properties)) {\n            const property = properties[k];\n            if (!isRef(property)) {\n              const nextSchemaKey = this.createSchemaKey(\n                parentSchemaKey,\n                [`${k}`],\n                schemaKeysOptions,\n              );\n              this.extractSchemaPathAsSchema(\n                parentSchemaKey,\n                [propertiesKey, k],\n                nextSchemaKey,\n              );\n              dirty = true;\n              break;\n            }\n          }\n        }\n      }\n      if (propertiesKey === `items`) {\n        const properties = this.getSchema(parentSchemaKey)[propertiesKey];\n        if (isRecord(properties) && !isRef(properties)) {\n          const nextSchemaKey = this.createSchemaKey(\n            parentSchemaKey,\n            [`item`],\n            schemaKeysOptions,\n          );\n          this.extractSchemaPathAsSchema(\n            parentSchemaKey,\n            [`items`],\n            nextSchemaKey,\n          );\n          dirty = true;\n        }\n      }\n      if (dirty) {\n        globalDirty = true;\n      }\n    }\n    return globalDirty;\n  };\n\n  private readonly extractSchemaProperties = (\n    schemaKey: string,\n    propertiesKeys: ExtractSchemaPropertiesKey[],\n    schemaKeysOptions?: SchemaKeysOptions,\n  ): boolean => {\n    let globalDirty = false;\n    let dirty = true;\n    while (dirty) {\n      dirty = false;\n      for (const propertiesKey of propertiesKeys) {\n        if (\n          this.extractSchemaPropertiesAtKey(\n            schemaKey,\n            propertiesKey,\n            schemaKeysOptions,\n          )\n        ) {\n          dirty = true;\n        }\n      }\n      if (dirty) {\n        globalDirty = true;\n      }\n    }\n    for (const propertiesKey of propertiesKeys) {\n      if (\n        this.extractSchemaPropertiesAtKey(\n          schemaKey,\n          propertiesKey,\n          schemaKeysOptions,\n        )\n      ) {\n        this.extractSchemaProperties(\n          schemaKey,\n          propertiesKeys,\n          schemaKeysOptions,\n        );\n        return true;\n      }\n    }\n    return globalDirty;\n  };\n\n  private readonly extractSchemasProperties = (\n    propertiesKeys: ExtractSchemaPropertiesKey[],\n    schemaKeysOptions?: SchemaKeysOptions,\n  ): void => {\n    this._DEBUG(`extractSchemasProperties`);\n    let dirty = true;\n    while (dirty) {\n      dirty = false;\n      for (const schemaKey of this.getSchemaKeys()) {\n        if (\n          this.extractSchemaProperties(\n            schemaKey,\n            propertiesKeys,\n            schemaKeysOptions,\n          )\n        ) {\n          dirty = true;\n          break;\n        }\n      }\n    }\n  };\n\n  private readonly mergeRef = (prev$ref: string): boolean => {\n    const [schema, next$ref] = this.resolveRef(prev$ref);\n    let globalDirty = false;\n    let dirty = true;\n    while (dirty) {\n      dirty = false;\n      visitDeep(this.spec, (value, path) => {\n        if (value !== schema && deepEqual(value, schema)) {\n          this.setAtPath(path, {\n            $ref: next$ref,\n          });\n          dirty = true;\n        }\n      });\n      if (dirty) {\n        globalDirty = true;\n      }\n    }\n    return globalDirty;\n  };\n\n  private readonly mergeRefs = ($refs: string[]): void => {\n    let dirty = true;\n    while (dirty) {\n      dirty = false;\n      for (const $ref of $refs) {\n        if (this.mergeRef($ref)) {\n          dirty = true;\n          break;\n        }\n      }\n    }\n  };\n\n  public readonly transformWithTimings = (\n    opts: TransformOptions = {},\n  ): TransformWithTimingsResult => {\n    const [\n      {\n        rewriteSchemasAbsoluteRefs,\n        extractSchemasProperties,\n        mergeRefs,\n        deleteUnusedSchemas,\n      },\n      total,\n    ] = withTimings(() => {\n      const [, rewriteSchemasAbsoluteRefs] = withTimings(() => {\n        if (opts.rewriteSchemasAbsoluteRefs === false) {\n          return;\n        }\n        this.rewriteSchemasAbsoluteRefs();\n      });\n\n      const [, mergeRefs] = withTimings(() => {\n        if (opts.mergeRefs) {\n          this.mergeRefs(opts.mergeRefs.map((ref) => ref.$ref));\n        }\n      });\n\n      this._DEBUG({ mergeRefs });\n\n      this._DEBUG({ rewriteSchemasAbsoluteRefs });\n\n      const [, extractSchemasProperties] = withTimings(() => {\n        if (opts.extractSchemasProperties === false) {\n          return;\n        }\n        const extractSchemasPropertiesKeys = !Array.isArray(\n          opts.extractSchemasProperties,\n        )\n          ? defaultExtractSchemaPropertiesKey\n          : opts.extractSchemasProperties;\n        this.extractSchemasProperties(\n          extractSchemasPropertiesKeys,\n          opts.schemaKeys,\n        );\n      });\n\n      this._DEBUG({ extractSchemasProperties });\n\n      const [, deleteUnusedSchemas] = withTimings(() => {\n        if (opts.deleteUnusedSchemas === false) {\n          return;\n        }\n        this.deleteUnusedSchemas();\n      });\n\n      this._DEBUG({ deleteUnusedSchemas });\n\n      return {\n        rewriteSchemasAbsoluteRefs,\n        extractSchemasProperties,\n        mergeRefs,\n        deleteUnusedSchemas,\n      };\n    });\n\n    this._DEBUG({ total });\n\n    return {\n      spec: this.spec,\n      timings: {\n        rewriteSchemasAbsoluteRefs,\n        extractSchemasProperties,\n        mergeRefs,\n        deleteUnusedSchemas,\n        total,\n      },\n    };\n  };\n\n  public readonly transform = (opts: TransformOptions = {}): Spec =>\n    this.transformWithTimings(opts).spec;\n}\n"],"mappings":";;;;;;;AAAA;;AAEA;;AACA;;AAEA;;AAUA;;;;AAMA,MAAMA,KAAK,GAAIC,GAAD,IAA8B;EAC1C,IAAI,CAAC,IAAAC,eAAA,EAASD,GAAT,CAAL,EAAoB;IAClB,OAAO,KAAP;EACD;;EACD,OAAO,OAAOA,GAAG,CAACE,IAAX,KAAqB,QAA5B;AACD,CALD;;AAYA,MAAMC,SAAS,GAAID,IAAD,IAA2B;EAC3C,MAAME,WAAW,GAAGF,IAAI,CAACG,OAAL,CAAc,GAAd,CAApB;EACA,OAAO;IACLC,QAAQ,EAAEJ,IAAI,CAACK,KAAL,CAAW,CAAX,EAAcH,WAAd,CADL;IAELI,IAAI,EAAEN,IAAI,CACPK,KADG,CACGH,WAAW,GAAG,CADjB,EAEHK,KAFG,CAEI,GAFJ,EAGHF,KAHG,CAGG,CAHH;EAFD,CAAP;AAOD,CATD;;AAWA,MAAMG,KAAK,GAAIC,OAAD,KAA4B;EACxCT,IAAI,EAAE,CAAE,GAAES,OAAO,CAACL,QAAS,GAArB,EAAyB,GAAGK,OAAO,CAACH,IAApC,EAA0CI,IAA1C,CAAgD,GAAhD;AADkC,CAA5B,CAAd;;AAWA,MAAMC,YAAY,GAAIC,KAAD,IAAyC;EAC5D,IAAI,CAAC,IAAAb,eAAA,EAASa,KAAT,CAAL,EAAsB;IACpB,OAAO,KAAP;EACD;;EACD,MAAM;IAAEC,UAAF;IAAcC,oBAAd;IAAoCC,iBAApC;IAAuDC;EAAvD,IAAiEJ,KAAvE;;EACA,IAAI,OAAOC,UAAP,KAAuB,WAAvB,IAAqC,CAAC,IAAAd,eAAA,EAASc,UAAT,CAA1C,EAAgE;IAC9D,OAAO,KAAP;EACD;;EAED,IACE,OAAOC,oBAAP,KAAiC,WAAjC,IACA,OAAOA,oBAAP,KAAiC,SADjC,IAEA,CAAC,IAAAf,eAAA,EAASe,oBAAT,CAHH,EAIE;IACA,OAAO,KAAP;EACD;;EAED,IACE,OAAOC,iBAAP,KAA8B,WAA9B,IACA,OAAOA,iBAAP,KAA8B,SAD9B,IAEA,CAAC,IAAAhB,eAAA,EAASgB,iBAAT,CAHH,EAIE;IACA,OAAO,KAAP;EACD;;EAED,IAAI,OAAOC,KAAP,KAAkB,WAAlB,IAAgC,CAAC,IAAAjB,eAAA,EAASiB,KAAT,CAArC,EAAsD;IACpD,OAAO,KAAP;EACD;;EAED,OAAO,IAAP;AACD,CA9BD;;AAkCA,MAAMC,aAAa,GAAIL,KAAD,IAA0C;EAC9D,IAAI,CAAC,IAAAb,eAAA,EAASa,KAAT,CAAL,EAAsB;IACpB,OAAO,KAAP;EACD;;EACD,KAAK,MAAMM,KAAX,IAAoBC,MAAM,CAACC,MAAP,CAAcR,KAAd,CAApB,EAA0C;IACxC,IAAI,CAACD,YAAY,CAACO,KAAD,CAAjB,EAA0B;MACxB,OAAO,KAAP;IACD;EACF;;EACD,OAAO,IAAP;AACD,CAVD;;AAmBA,MAAMG,aAAa,GAAIT,KAAD,IAA0C;EAC9D,IAAI,CAAC,IAAAb,eAAA,EAASa,KAAT,CAAL,EAAsB;IACpB,OAAO,KAAP;EACD;;EACD,MAAM;IAAEU,UAAF;IAAcC;EAAd,IAAwBX,KAA9B;;EACA,IAAI,CAAC,IAAAb,eAAA,EAASuB,UAAT,CAAL,EAA2B;IACzB,OAAO,KAAP;EACD;;EACD,MAAM;IAAEE;EAAF,IAAcF,UAApB;;EACA,IAAI,CAACL,aAAa,CAACO,OAAD,CAAlB,EAA6B;IAC3B,OAAO,KAAP;EACD;;EACD,IAAI,OAAOD,KAAP,KAAkB,WAAlB,IAAgC,CAAC,IAAAxB,eAAA,EAASwB,KAAT,CAArC,EAAsD;IACpD,OAAO,KAAP;EACD;;EACD,OAAO,IAAP;AACD,CAhBD;;AAuBA,MAAME,aAAa,GAAIb,KAAD,IAA0C;EAC9D,IAAI,CAAC,IAAAb,eAAA,EAASa,KAAT,CAAL,EAAsB;IACpB,OAAO,KAAP;EACD;;EACD,MAAM;IAAEc,WAAF;IAAeH;EAAf,IAAyBX,KAA/B;;EACA,IAAI,CAACK,aAAa,CAACS,WAAD,CAAlB,EAAiC;IAC/B,OAAO,KAAP;EACD;;EACD,IAAI,OAAOH,KAAP,KAAkB,WAAlB,IAAgC,CAAC,IAAAxB,eAAA,EAASwB,KAAT,CAArC,EAAsD;IACpD,OAAO,KAAP;EACD;;EACD,OAAO,IAAP;AACD,CAZD;;AAgBA,MAAMI,MAAM,GAAIf,KAAD,IACbS,aAAa,CAACT,KAAD,CAAb,IAAwBa,aAAa,CAACb,KAAD,CADvC;;AAGA,MAAMgB,SAAS,GAAIC,IAAD,IAAsBC,IAAI,CAACC,KAAL,CAAWD,IAAI,CAACE,SAAL,CAAeH,IAAf,CAAX,CAAxC;;AAQA,MAAMI,iCAA+D,GAAG,CACrE,YADqE,EAErE,sBAFqE,EAGrE,mBAHqE,EAIrE,OAJqE,CAAxE;;AAaA,MAAMC,WAAW,GAAOC,EAAJ,IAAmD;EACrE,MAAMC,KAAK,GAAGC,WAAW,CAACC,GAAZ,EAAd;EACA,MAAMC,MAAM,GAAGJ,EAAE,EAAjB;EACA,MAAMK,GAAG,GAAGH,WAAW,CAACC,GAAZ,EAAZ;EAEA,OAAO,CACLC,MADK,EAEL;IACEH,KADF;IAEEI,GAFF;IAGEC,KAAK,EAAED,GAAG,GAAGJ;EAHf,CAFK,CAAP;AAQD,CAbD;;AA4CO,MAAMM,eAAN,CAAsB;EAOpBC,WAAW,CAACd,IAAD,EAAgBe,KAAK,GAAG,KAAxB,EAA+B;IAC/C,IAAI,CAACjB,MAAM,CAACE,IAAD,CAAX,EAAmB;MACjB,MAAM,IAAIgB,KAAJ,CAAW,6CAAX,CAAN;IACD;;IACD,KAAKhB,IAAL,GAAYD,SAAS,CAACC,IAAD,CAArB;IACA,KAAKiB,WAAL,GAAmBzB,aAAa,CAACQ,IAAD,CAAb,GACf,CAAE,YAAF,EAAgB,SAAhB,CADe,GAEf,CAAE,aAAF,CAFJ;IAGA,KAAKkB,iBAAL,GAAyB,KAAKC,aAAL,EAAzB;IACA,KAAKJ,KAAL,GAAaA,KAAb;EACD;;EAEgBK,MAAM,GAAG,CAAC,GAAGC,IAAJ,KAA8B;IACtD,IAAI,KAAKN,KAAT,EAAgB;MACdO,OAAO,CAACC,KAAR,CAAc,GAAGF,IAAjB;IACD;EACF,CAJsB;EAMNG,KAAK,GAAIC,KAAD,IAA2B;IAClD,IAAI,KAAKV,KAAT,EAAgB;MACdO,OAAO,CAACC,KAAR,CAAc,IAAAG,aAAA,EAAQ,KAAK1B,IAAb,EAAmB;QAAE2B,KAAK,EAAE;MAAT,CAAnB,CAAd;MACAL,OAAO,CAACG,KAAR,CAAcA,KAAd;IACD;;IACD,MAAMA,KAAN;EACD,CANqB;EAQLG,aAAa,GAAIC,SAAD,IAC/B,IAAAC,kBAAA,EAAa,IAAAA,kBAAA,EAAa,KAAKb,WAAlB,EAA+BY,SAA/B,CAAb,CAD4B;EAGbE,SAAS,GAAIF,SAAD,IAAmC;IAC9D,MAAMG,MAAM,GAAG,KAAKC,SAAL,CAAe,KAAKL,aAAL,CAAmBC,SAAnB,CAAf,CAAf;;IACA,IAAI,CAAC/C,YAAY,CAACkD,MAAD,CAAjB,EAA2B;MACzB,OAAO,KAAKR,KAAL,CAAW,IAAIR,KAAJ,CAAW,4BAAX,CAAX,CAAP;IACD;;IACD,OAAOgB,MAAP;EACD,CANyB;EAQTb,aAAa,GAAG,MAAgB;IAC/C,MAAMxB,OAAO,GAAG,KAAKsC,SAAL,CAAe,KAAKhB,WAApB,CAAhB;;IACA,IAAI,CAAC,IAAA/C,eAAA,EAASyB,OAAT,CAAL,EAAwB;MACtB,OAAO,KAAK6B,KAAL,CAAW,IAAIR,KAAJ,CAAW,yBAAX,CAAX,CAAP;IACD;;IACD,OAAO1B,MAAM,CAAC4C,IAAP,CAAYvC,OAAZ,CAAP;EACD,CAN6B;EAQbwC,eAAe,GAAG,CACjCC,eADiC,EAEjC3D,IAFiC,EAGjC4D,iBAHiC,KAItB;IACX,MAAMC,KAAe,GAAG,EAAxB;;IACA,IACE,EAACD,iBAAD,aAACA,iBAAD,eAACA,iBAAiB,CAAEE,0BAApB,KACA,CAAC,KAAKrB,iBAAL,CAAuBsB,QAAvB,CAAgCJ,eAAhC,CAFH,EAGE;MACAE,KAAK,CAACG,IAAN,CAAWL,eAAX;IACD;;IACDE,KAAK,CAACG,IAAN,CAAW,GAAGhE,IAAd;IACA,MAAMiE,QAAQ,GAAGJ,KAAK,CAACzD,IAAN,CAAY,GAAZ,CAAjB;IACA,MAAMgD,SAAS,GACb,CAAAQ,iBAAiB,SAAjB,IAAAA,iBAAiB,WAAjB,YAAAA,iBAAiB,CAAEM,UAAnB,MAAmC,YAAnC,GACI,IAAAC,sBAAA,EAAWF,QAAX,CADJ,GAEI,CAAAL,iBAAiB,SAAjB,IAAAA,iBAAiB,WAAjB,YAAAA,iBAAiB,CAAEM,UAAnB,MAAmC,WAAnC,GACA,IAAAE,qBAAA,EAAUH,QAAV,CADA,GAEA,CAAAL,iBAAiB,SAAjB,IAAAA,iBAAiB,WAAjB,YAAAA,iBAAiB,CAAEM,UAAnB,MAAmC,YAAnC,GACA,IAAAG,qBAAA,EAAUJ,QAAV,CADA,GAEA,CAAAL,iBAAiB,SAAjB,IAAAA,iBAAiB,WAAjB,YAAAA,iBAAiB,CAAEM,UAAnB,MAAmC,YAAnC,GACA,IAAAI,qBAAA,EAAUL,QAAV,CADA,GAEAA,QATN;;IAUA,IAAI,KAAKvB,aAAL,GAAqBqB,QAArB,CAA8BX,SAA9B,CAAJ,EAA8C;MAC5C,MAAM,IAAIb,KAAJ,CAAW,wBAAuBa,SAAU,mBAA5C,CAAN;IACD;;IACD,OAAOA,SAAP;EACD,CA5B+B;EA8BfI,SAAS,GAAIxD,IAAD,IAC3B,IAAAwD,eAAA,EAAU,KAAKjC,IAAf,EAAqBvB,IAArB,CADwB;EAGTuE,aAAa,GAC5BvE,IAD+B,IAEW,IAAAuE,mBAAA,EAAc,KAAKhD,IAAnB,EAAyBvB,IAAzB,CAFd;EAIbwE,UAAU,GACzB9E,IAD4B,IAEO;IACnC,MAAMS,OAAO,GAAGR,SAAS,CAACD,IAAD,CAAzB;;IACA,IAAIS,OAAO,CAACL,QAAR,CAAiB2E,MAAjB,GAA0B,CAA9B,EAAiC;MAC/B,MAAMC,OAAO,GAAGxE,KAAK,CAAC;QACpBJ,QAAQ,EAAG,EADS;QAEpBE,IAAI,EAAE,IAAAqD,kBAAA,EACJ,KAAKF,aAAL,CAAmBhD,OAAO,CAACL,QAA3B,CADI,EAEJ,GAAGK,OAAO,CAACH,IAFP;MAFc,CAAD,CAArB;MAOA,OAAO,KAAKwE,UAAL,CAAgBE,OAAO,CAAChF,IAAxB,CAAP;IACD;;IACD,MAAMkB,KAAK,GAAG,KAAK4C,SAAL,CAAerD,OAAO,CAACH,IAAvB,CAAd;;IACA,IAAIT,KAAK,CAACqB,KAAD,CAAT,EAAkB;MAChB,OAAO,KAAK4D,UAAL,CAAgB5D,KAAK,CAAClB,IAAtB,CAAP;IACD;;IACD,OAAO,CAACkB,KAAD,EAAQlB,IAAR,CAAP;EACD,CAnB0B;EAqBViF,SAAS,GAAG,CAAC3E,IAAD,EAAiBY,KAAjB,KAA0C;IACrE,KAAK+B,MAAL,CAAa,WAAb,EAAyB;MAAE3C,IAAF;MAAQY;IAAR,CAAzB;;IACA,OAAO,IAAA+D,eAAA,EAAU,KAAKpD,IAAf,EAAqBvB,IAArB,EAA2BY,KAA3B,CAAP;EACD,CAHyB;EAKTgE,YAAY,GAAI5E,IAAD,IAA0B;IACxD,KAAK2C,MAAL,CAAa,cAAb,EAA4B;MAAE3C;IAAF,CAA5B;;IACA,OAAO,IAAA4E,kBAAA,EAAa,KAAKrD,IAAlB,EAAwBvB,IAAxB,CAAP;EACD,CAH4B;EAKZ6E,aAAa,GAC5BC,SAD+B,IAG/B,IAAAD,oBAAA,EAAc,KAAKtD,IAAnB,EAAyBuD,SAAzB,CAH4B;EAKbC,YAAY,GAAI3B,SAAD,IAAgC;IAC9D,MAAM4B,UAAU,GAAG,KAAK7B,aAAL,CAAmBC,SAAnB,CAAnB;IACA,MAAM,CAAC2B,YAAD,IAAiB,KAAKF,aAAL,CAAmB,CAACjE,KAAD,EAAQZ,IAAR,KAAiB;MACzD,IAAI,IAAAiF,eAAA,EAAUjF,IAAV,EAAgBgF,UAAhB,CAAJ,EAAiC;QAC/B,OAAO,KAAP;MACD;;MACD,IAAIzF,KAAK,CAACqB,KAAD,CAAT,EAAkB;QAChB,MAAMT,OAAO,GAAGR,SAAS,CAACiB,KAAK,CAAClB,IAAP,CAAzB;QACA,OACES,OAAO,CAACL,QAAR,CAAiB2E,MAAjB,KAA4B,CAA5B,IACA,IAAAS,qBAAA,EAAgBF,UAAhB,EAA4B7E,OAAO,CAACH,IAApC,CAFF;MAID;;MACD,OAAO,KAAP;IACD,CAZsB,CAAvB;IAaA,OAAO+E,YAAP;EACD,CAhB4B;EAkBZI,mBAAmB,GAAG,MAAY;IACjD,KAAKxC,MAAL,CAAa,qBAAb;;IACA,IAAIyC,KAAK,GAAG,IAAZ;;IACA,OAAOA,KAAP,EAAc;MACZA,KAAK,GAAG,KAAR;;MACA,KAAK,MAAMhC,SAAX,IAAwB,KAAKV,aAAL,EAAxB,EAA8C;QAC5C,IAAI,CAAC,KAAKqC,YAAL,CAAkB3B,SAAlB,CAAL,EAAmC;UACjC,KAAKwB,YAAL,CAAkB,KAAKzB,aAAL,CAAmBC,SAAnB,CAAlB;UACAgC,KAAK,GAAG,IAAR;UACA;QACD;MACF;IACF;EACF,CAbmC;EAenBC,yBAAyB,GAAIjC,SAAD,IAAgC;IAC3E,MAAMG,MAAM,GAAG,KAAKD,SAAL,CAAeF,SAAf,CAAf;IACA,MAAM4B,UAAU,GAAG,KAAK7B,aAAL,CAAmBC,SAAnB,CAAnB;IACA,IAAIgC,KAAK,GAAG,KAAZ;IACA,IAAAE,gBAAA,EAAU/B,MAAV,EAAmB3C,KAAD,IAAW;MAC3B,IAAIrB,KAAK,CAACqB,KAAD,CAAT,EAAkB;QAChB,MAAMT,OAAO,GAAGR,SAAS,CAACiB,KAAK,CAAClB,IAAP,CAAzB;;QACA,IACES,OAAO,CAACL,QAAR,CAAiB2E,MAAjB,KAA4B,CAA5B,IACA,CAAC,IAAAS,qBAAA,EAAgBF,UAAhB,EAA4B7E,OAAO,CAACH,IAApC,CAFH,EAGE;UACA,MAAMuF,QAAQ,GAAG,IAAAlC,kBAAA,EAAa2B,UAAb,EAAyB,GAAG7E,OAAO,CAACH,IAApC,CAAjB;UACAY,KAAK,CAAClB,IAAN,GAAaQ,KAAK,CAAC;YAAEJ,QAAQ,EAAG,EAAb;YAAgBE,IAAI,EAAEuF;UAAtB,CAAD,CAAL,CAAwC7F,IAArD;UACA0F,KAAK,GAAG,IAAR;QACD;MACF;IACF,CAZD;IAaA,OAAOA,KAAP;EACD,CAlByC;EAoBzBI,0BAA0B,GAAG,MAAY;IACxD,KAAK7C,MAAL,CAAa,4BAAb;;IACA,IAAIyC,KAAK,GAAG,IAAZ;;IACA,OAAOA,KAAP,EAAc;MACZA,KAAK,GAAG,KAAR;;MACA,KAAK,MAAMhC,SAAX,IAAwB,KAAKV,aAAL,EAAxB,EAA8C;QAC5C,IAAI,KAAK2C,yBAAL,CAA+BjC,SAA/B,CAAJ,EAA+C;UAC7CgC,KAAK,GAAG,IAAR;UACA;QACD;MACF;IACF;EACF,CAZ0C;EAc1BK,yBAAyB,GAAG,CAC3CC,aAD2C,EAE3CC,gBAF2C,EAG3CC,aAH2C,KAI/B;IACZ,MAAMC,QAAQ,GAAG,IAAAxC,kBAAA,EACf,KAAKF,aAAL,CAAmBuC,aAAnB,CADe,EAEf,GAAGC,gBAFY,CAAjB;IAKA,MAAMG,SAAS,GAAG,KAAKtC,SAAL,CAAeqC,QAAf,CAAlB;IACA,MAAMN,QAAQ,GAAG,KAAKpC,aAAL,CAAmByC,aAAnB,CAAjB;IAEA,MAAM,CAACG,kBAAD,EAAqBC,eAArB,IAAwC,KAAKzB,aAAL,CAAmBgB,QAAnB,CAA9C;;IAEA,IAAIQ,kBAAJ,EAAwB;MACtB,IAAI,CAAC,IAAAE,sBAAA,EAAUH,SAAV,EAAqBE,eAArB,CAAL,EAA4C;QAC1C,KAAKjD,KAAL,CACE,IAAIR,KAAJ,CACG,qBAAoBqD,aAAc,0CADrC,CADF;MAKD;IACF,CARD,MAQO;MACL,KAAKjB,SAAL,CAAeY,QAAf,EAAyBO,SAAzB;IACD;;IAED,KAAKnB,SAAL,CAAekB,QAAf,EAAyB3F,KAAK,CAAC;MAAEJ,QAAQ,EAAG,EAAb;MAAgBE,IAAI,EAAEuF;IAAtB,CAAD,CAA9B;IAEA,IAAIH,KAAK,GAAG,KAAZ;IACA,IAAAE,gBAAA,EAAU,KAAK/D,IAAf,EAAsBX,KAAD,IAAW;MAC9B,IAAIrB,KAAK,CAACqB,KAAD,CAAT,EAAkB;QAChB,MAAMT,OAAO,GAAGR,SAAS,CAACiB,KAAK,CAAClB,IAAP,CAAzB;;QACA,IACES,OAAO,CAACL,QAAR,CAAiB2E,MAAjB,KAA4B,CAA5B,IACA,IAAAS,qBAAA,EAAgBW,QAAhB,EAA0B1F,OAAO,CAACH,IAAlC,CAFF,EAGE;UACAY,KAAK,CAAClB,IAAN,GAAaQ,KAAK,CAAC;YACjBJ,QAAQ,EAAG,EADM;YAEjBE,IAAI,EAAE,IAAAkG,uBAAA,EAAkBL,QAAlB,EAA4BN,QAA5B,EAAsCpF,OAAO,CAACH,IAA9C;UAFW,CAAD,CAAL,CAGVN,IAHH;UAIA0F,KAAK,GAAG,IAAR;QACD;MACF;IACF,CAdD;IAeA,OAAOA,KAAP;EACD,CA9CyC;EAgDzBe,4BAA4B,GAAG,CAC9CxC,eAD8C,EAE9CyC,aAF8C,EAG9CxC,iBAH8C,KAIlC;IACZ,IAAIyC,WAAW,GAAG,KAAlB;IACA,IAAIjB,KAAK,GAAG,IAAZ;;IACA,OAAOA,KAAP,EAAc;MACZA,KAAK,GAAG,KAAR;;MACA,IACEgB,aAAa,KAAM,YAAnB,IACAA,aAAa,KAAM,sBADnB,IAEAA,aAAa,KAAM,mBAHrB,EAIE;QACA,MAAM7F,UAAU,GAAG,KAAK+C,SAAL,CAAeK,eAAf,EAAgCyC,aAAhC,CAAnB;;QACA,IAAI,IAAA3G,eAAA,EAASc,UAAT,CAAJ,EAA0B;UACxB,KAAK,MAAM+F,CAAX,IAAgBzF,MAAM,CAAC4C,IAAP,CAAYlD,UAAZ,CAAhB,EAAyC;YACvC,MAAMgG,QAAQ,GAAGhG,UAAU,CAAC+F,CAAD,CAA3B;;YACA,IAAI,CAAC/G,KAAK,CAACgH,QAAD,CAAV,EAAsB;cACpB,MAAMX,aAAa,GAAG,KAAKlC,eAAL,CACpBC,eADoB,EAEpB,CAAE,GAAE2C,CAAE,EAAN,CAFoB,EAGpB1C,iBAHoB,CAAtB;cAKA,KAAK6B,yBAAL,CACE9B,eADF,EAEE,CAACyC,aAAD,EAAgBE,CAAhB,CAFF,EAGEV,aAHF;cAKAR,KAAK,GAAG,IAAR;cACA;YACD;UACF;QACF;MACF;;MACD,IAAIgB,aAAa,KAAM,OAAvB,EAA+B;QAC7B,MAAM7F,UAAU,GAAG,KAAK+C,SAAL,CAAeK,eAAf,EAAgCyC,aAAhC,CAAnB;;QACA,IAAI,IAAA3G,eAAA,EAASc,UAAT,KAAwB,CAAChB,KAAK,CAACgB,UAAD,CAAlC,EAAgD;UAC9C,MAAMqF,aAAa,GAAG,KAAKlC,eAAL,CACpBC,eADoB,EAEpB,CAAE,MAAF,CAFoB,EAGpBC,iBAHoB,CAAtB;UAKA,KAAK6B,yBAAL,CACE9B,eADF,EAEE,CAAE,OAAF,CAFF,EAGEiC,aAHF;UAKAR,KAAK,GAAG,IAAR;QACD;MACF;;MACD,IAAIA,KAAJ,EAAW;QACTiB,WAAW,GAAG,IAAd;MACD;IACF;;IACD,OAAOA,WAAP;EACD,CAxD4C;EA0D5BG,uBAAuB,GAAG,CACzCpD,SADyC,EAEzCqD,cAFyC,EAGzC7C,iBAHyC,KAI7B;IACZ,IAAIyC,WAAW,GAAG,KAAlB;IACA,IAAIjB,KAAK,GAAG,IAAZ;;IACA,OAAOA,KAAP,EAAc;MACZA,KAAK,GAAG,KAAR;;MACA,KAAK,MAAMgB,aAAX,IAA4BK,cAA5B,EAA4C;QAC1C,IACE,KAAKN,4BAAL,CACE/C,SADF,EAEEgD,aAFF,EAGExC,iBAHF,CADF,EAME;UACAwB,KAAK,GAAG,IAAR;QACD;MACF;;MACD,IAAIA,KAAJ,EAAW;QACTiB,WAAW,GAAG,IAAd;MACD;IACF;;IACD,KAAK,MAAMD,aAAX,IAA4BK,cAA5B,EAA4C;MAC1C,IACE,KAAKN,4BAAL,CACE/C,SADF,EAEEgD,aAFF,EAGExC,iBAHF,CADF,EAME;QACA,KAAK4C,uBAAL,CACEpD,SADF,EAEEqD,cAFF,EAGE7C,iBAHF;QAKA,OAAO,IAAP;MACD;IACF;;IACD,OAAOyC,WAAP;EACD,CAzCuC;EA2CvBK,wBAAwB,GAAG,CAC1CD,cAD0C,EAE1C7C,iBAF0C,KAGjC;IACT,KAAKjB,MAAL,CAAa,0BAAb;;IACA,IAAIyC,KAAK,GAAG,IAAZ;;IACA,OAAOA,KAAP,EAAc;MACZA,KAAK,GAAG,KAAR;;MACA,KAAK,MAAMhC,SAAX,IAAwB,KAAKV,aAAL,EAAxB,EAA8C;QAC5C,IACE,KAAK8D,uBAAL,CACEpD,SADF,EAEEqD,cAFF,EAGE7C,iBAHF,CADF,EAME;UACAwB,KAAK,GAAG,IAAR;UACA;QACD;MACF;IACF;EACF,CArBwC;EAuBxBuB,QAAQ,GAAIC,QAAD,IAA+B;IACzD,MAAM,CAACrD,MAAD,EAASsD,QAAT,IAAqB,KAAKrC,UAAL,CAAgBoC,QAAhB,CAA3B;IACA,IAAIP,WAAW,GAAG,KAAlB;IACA,IAAIjB,KAAK,GAAG,IAAZ;;IACA,OAAOA,KAAP,EAAc;MACZA,KAAK,GAAG,KAAR;MACA,IAAAE,gBAAA,EAAU,KAAK/D,IAAf,EAAqB,CAACX,KAAD,EAAQZ,IAAR,KAAiB;QACpC,IAAIY,KAAK,KAAK2C,MAAV,IAAoB,IAAA0C,sBAAA,EAAUrF,KAAV,EAAiB2C,MAAjB,CAAxB,EAAkD;UAChD,KAAKoB,SAAL,CAAe3E,IAAf,EAAqB;YACnBN,IAAI,EAAEmH;UADa,CAArB;UAGAzB,KAAK,GAAG,IAAR;QACD;MACF,CAPD;;MAQA,IAAIA,KAAJ,EAAW;QACTiB,WAAW,GAAG,IAAd;MACD;IACF;;IACD,OAAOA,WAAP;EACD,CAnBwB;EAqBRS,SAAS,GAAIC,KAAD,IAA2B;IACtD,IAAI3B,KAAK,GAAG,IAAZ;;IACA,OAAOA,KAAP,EAAc;MACZA,KAAK,GAAG,KAAR;;MACA,KAAK,MAAM1F,IAAX,IAAmBqH,KAAnB,EAA0B;QACxB,IAAI,KAAKJ,QAAL,CAAcjH,IAAd,CAAJ,EAAyB;UACvB0F,KAAK,GAAG,IAAR;UACA;QACD;MACF;IACF;EACF,CAXyB;EAaV4B,oBAAoB,GAAG,CACrCC,IAAsB,GAAG,EADY,KAEN;IAC/B,MAAM,CACJ;MACEzB,0BADF;MAEEkB,wBAFF;MAGEI,SAHF;MAIE3B;IAJF,CADI,EAOJ+B,KAPI,IAQFtF,WAAW,CAAC,MAAM;MACpB,MAAM,GAAG4D,0BAAH,IAAiC5D,WAAW,CAAC,MAAM;QACvD,IAAIqF,IAAI,CAACzB,0BAAL,KAAoC,KAAxC,EAA+C;UAC7C;QACD;;QACD,KAAKA,0BAAL;MACD,CALiD,CAAlD;MAOA,MAAM,GAAGsB,SAAH,IAAgBlF,WAAW,CAAC,MAAM;QACtC,IAAIqF,IAAI,CAACH,SAAT,EAAoB;UAClB,KAAKA,SAAL,CAAeG,IAAI,CAACH,SAAL,CAAeK,GAAf,CAAoB3H,GAAD,IAASA,GAAG,CAACE,IAAhC,CAAf;QACD;MACF,CAJgC,CAAjC;;MAMA,KAAKiD,MAAL,CAAY;QAAEmE;MAAF,CAAZ;;MAEA,KAAKnE,MAAL,CAAY;QAAE6C;MAAF,CAAZ;;MAEA,MAAM,GAAGkB,wBAAH,IAA+B9E,WAAW,CAAC,MAAM;QACrD,IAAIqF,IAAI,CAACP,wBAAL,KAAkC,KAAtC,EAA6C;UAC3C;QACD;;QACD,MAAMU,4BAA4B,GAAG,CAACC,KAAK,CAACC,OAAN,CACpCL,IAAI,CAACP,wBAD+B,CAAD,GAGjC/E,iCAHiC,GAIjCsF,IAAI,CAACP,wBAJT;QAKA,KAAKA,wBAAL,CACEU,4BADF,EAEEH,IAAI,CAACM,UAFP;MAID,CAb+C,CAAhD;;MAeA,KAAK5E,MAAL,CAAY;QAAE+D;MAAF,CAAZ;;MAEA,MAAM,GAAGvB,mBAAH,IAA0BvD,WAAW,CAAC,MAAM;QAChD,IAAIqF,IAAI,CAAC9B,mBAAL,KAA6B,KAAjC,EAAwC;UACtC;QACD;;QACD,KAAKA,mBAAL;MACD,CAL0C,CAA3C;;MAOA,KAAKxC,MAAL,CAAY;QAAEwC;MAAF,CAAZ;;MAEA,OAAO;QACLK,0BADK;QAELkB,wBAFK;QAGLI,SAHK;QAIL3B;MAJK,CAAP;IAMD,CAlDc,CARf;;IA4DA,KAAKxC,MAAL,CAAY;MAAEuE;IAAF,CAAZ;;IAEA,OAAO;MACL3F,IAAI,EAAE,KAAKA,IADN;MAELiG,OAAO,EAAE;QACPhC,0BADO;QAEPkB,wBAFO;QAGPI,SAHO;QAIP3B,mBAJO;QAKP+B;MALO;IAFJ,CAAP;EAUD,CA3EmC;EA6EpBO,SAAS,GAAG,CAACR,IAAsB,GAAG,EAA1B,KAC1B,KAAKD,oBAAL,CAA0BC,IAA1B,EAAgC1F,IADT;AA3dE"}